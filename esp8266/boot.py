# Dies ist das erste Skript, welches beim Gerätestart ausgeführt wird (auch beim Aufwachen aus dem Tiefschlaf ("deep sleep"))# Nachdem dieses Skript ausgeführt wurde, wird automatisch das Skript "main.py" ausgeführt, sofern vorhandenfrom networking import initialisefrom cb_handler import module_callback, device_callbackimport check_space# Allgemeiner Callback Handler# Funktion, die anhand des Topics bzw. des Vorhandenseins der, für die IoT4School-Module verwendeten, dict-Variable schaut,# ob die Nachricht für den Controller selbst (device_callback) oder für die Module (module_callback) bestimmt istdef general_callback(topic, msg, retain, duplicate):    global network_manager    if topic == b'sub/{}'.format(network_manager.device_id):        device_callback(topic, msg, retain, duplicate)    elif 'dict' in globals():        module_callback(dict, network_manager.device_id, topic, msg, retain, duplicate)    # Dieser Fall tritt nur ein, wenn man eigenständig einen Subscribe gesetzt hat, den Callback aber nicht überschreibt    else:        print('[ERROR] Eigener Subscribe gesetzt. Kann nicht gehandlet werden. Bitte definiere einen eigenen Callback.')# Über diese Funktion wird Netzwerkkommunikation initialisiert# Return: Klasse NetworkManager network_manager = initialise()# Hier wird der Callback-Handler für alle eingehenden MQTT-Nachrichten gesetztnetwork_manager.mqtt_client.set_callback(general_callback)# Am Ende des Startvorgangs expliziter Aufruf des Garbage Collectors, um nicht mehr benötigten Speicher freizugebengc.collect()print('[DEBUG] Freier Speicherplatz:', check_space.df())print('[DEBUG] Freier RAM:', check_space.free(full=False))